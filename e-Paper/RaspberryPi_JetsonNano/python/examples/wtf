import time
import keymaps
import qrcode
import socket
from PIL import Image, ImageDraw, ImageFont
import os
import subprocess

font24 = ImageFont.truetype('Courier Prime.ttf', 18) #24

#Things to implement:
# 1: menu input (for wifi names, passwords, potentially filenames, etc)
# 2: menu scrolling (so we can generate menus beyond the screen limits)
# 3: 

class Menu:
    def __init__(self, display_draw, epd, display_image):
        self.display_draw = display_draw
        self.epd = epd
        self.display_image = display_image
        self.menu_items = []
        self.selected_item = 0
        #input related
        self.inputMode = False
        self.input_content = ""  # Clear input content
        self.cursor_position = 0  # Reset cursor position
        self.store_keypress = None

    def addItem(self, text, action):
        self.menu_items.append({'text': text, 'action': action})

    def up(self):
        self.selected_item -= 1
        if self.selected_item < 0:
            self.selected_item = len(self.menu_items) - 1
        self.display()
    
    def down(self):
        self.selected_item += 1
        if self.selected_item > len(self.menu_items) - 1:
            self.selected_item = 0
        self.display()

    def select(self):
        self.menu_items[self.selected_item]['action']()

    def display(self):
        self.display_draw.rectangle((0, 0, 400, 300), fill=255)
        y_position = 10
        for index, item in enumerate(self.menu_items):
            prefix = self.selected_item == index and "> " or "  "
            self.display_draw.text((10, y_position), prefix + item['text'], font=font24, fill=0)
            y_position += 30
        partial_buffer = self.epd.getbuffer(self.display_image)
        self.epd.display_Partial(partial_buffer)
        time.sleep(.1)

    def inputDisplay(self):
        cursor_index = self.cursor_position
        self.display_draw.rectangle((0, 270, 400, 300), fill=255)  # Clear display
        temp_content = self.input_content[:cursor_index] + "|" + self.input_content[cursor_index:]
        #draw input line text
        self.display_draw.text((10, 270), str(temp_content), font=font24, fill=0)        
        partial_buffer = self.epd.getbuffer(self.display_image)
        self.epd.display_Partial(partial_buffer)

    def getInput(self):
        self.inputMode = True  # Set input mode to True
        self.input_content = ""  # Clear input content
        self.cursor_position = 0  # Reset cursor position
        self.store_keypress = None
        time.sleep(.1)          
        self.inputDisplay()


class ZeroWriter:
    def __init__(self):
        self.epd = None
        self.display_image = None
        self.display_draw = None
        self.display_updating = False
        self.cursor_position = 0
        self.text_content = ""
        self.input_content = ""
        self.previous_lines = []
        self.needs_display_update = False
        self.needs_input_update = False
        self.chars_per_line = 32
        self.lines_on_screen = 12
        self.font_size = 18
        self.line_spacing = 22
        self.scrollindex = 1
        self.console_message = ""
        self.typing_last_time = 0
        self.updating_input_area = False
        self.control_active = False
        self.shift_active = False
        self.menu_mode = False
        self.menu = None
        self.parent_menu = None # used to store the menu that was open before the load menu was opened
        self.server_address = "not active"
        self.cache_file_path = os.path.join(os.path.dirname(__file__), 'data', 'cache.txt')
    
    def initialize(self):
        self.epd.init()
        self.epd.Clear()
        self.display_image = Image.new('1', (self.epd.width, self.epd.height), 255)
        self.display_draw = ImageDraw.Draw(self.display_image)
        self.last_display_update = time.time()

        self.start_server()

        self.keyboard.on_press(self.handle_key_down, suppress=False) #handles modifiers and shortcuts
        self.keyboard.on_release(self.handle_key_press, suppress=True)

        self.menu = Menu(self.display_draw, self.epd, self.display_image)
        self.menu.addItem("Test", lambda: self.menu.getInpu())
        self.menu.addItem("New", lambda: self.new_file())
        self.menu.addItem("Load", lambda: self.show_load_menu())
        self.menu.addItem("Save", lambda: self.save_file())
        self.menu.addItem("QR Code", lambda: self.display_qr_code())
        self.menu.addItem(" ", lambda: print("blank spacer"))
        self.menu.addItem("Wifi: " + str(self.get_ssid()), lambda: self.show_networks_menu())
        self.menu.addItem("Files: " + str(self.server_address), lambda: print("enabled."))
        self.menu.addItem(" ", lambda: print("blank spacer"))
        self.menu.addItem("Power Off", self.power_down)

        self.load_menu = Menu(self.display_draw, self.epd, self.display_image)
        self.populate_load_menu()

        self.networks_menu = Menu(self.display_draw, self.epd, self.display_image)
        self.populate_networks_menu()

    def get_ssid(self):
        raw_wifi = subprocess.check_output(['iwgetid', '-r'])
        data_strings = raw_wifi.decode('utf-8').split()
        return data_strings

    def start_server(self):
        try:
            print("starting data server...")
            current_directory = os.path.join(os.getcwd(),"data")
            subprocess.Popen(["python", "-m", "http.server", str(8000)], cwd=current_directory, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            self.server_address=str(socket.gethostname() + ".local:8000")
        except Exception as e:
            print("error starting server...")

    def show_load_menu(self):
        self.parent_menu = self.menu
        self.populate_load_menu()
        self.menu = self.load_menu
        self.menu.display()

    def show_networks_menu(self):
        self.parent_menu = self.menu
        self.populate_networks_menu()
        self.menu = self.networks_menu
        self.menu.display()

    def hide_child_menu(self):
        self.menu = self.parent_menu
        self.menu.display()

    def populate_load_menu(self):
        self.load_menu.menu_items.clear()
        data_folder_path = os.path.join(os.path.dirname(__file__), 'data')
        try:
            # List all files in the data folder
            files = [f for f in os.listdir(data_folder_path) if os.path.isfile(os.path.join(data_folder_path, f)) and f.endswith('.txt')]
            # Sort files by modification time
            files.sort(key=lambda x: os.path.getmtime(os.path.join(data_folder_path, x)), reverse=True)

            self.load_menu.addItem("<- Back", self.hide_child_menu)
            self.load_menu.addItem("cache.txt autosave file", lambda f="cache.txt": self.load_file_into_previous_lines("cache.txt"))

            for filename in files:
                if filename != "cache.txt":
                    self.load_menu.addItem(filename, lambda f=filename: self.load_file_into_previous_lines(f))
        except Exception as e:
            print(f"Failed to list files in {data_folder_path}: {e}")

    def populate_networks_menu(self):
        self.networks_menu.menu_items.clear()

        try:
            available_networks = self.get_available_wifi_networks()
            self.networks_menu.addItem("<- Back", self.hide_child_menu)
            self.networks_menu.addItem("Manually Enter SSID", self.hide_child_menu)
            for network in available_networks:
                self.networks_menu.addItem(network, lambda n=network: self.connect_to_network(n))
        except Exception as e:
            print(f"Failed to populate networks menu: {e}") 

    def connect_to_network(self, network):
        print("ok")
        return

    def consolemsg(self, text):
        #this handles mini console messages
        self.console_message = text
        self.update_display()
        time.sleep(1)
        self.console_message = ""
        self.update_input_area()

    def load_file_into_previous_lines(self, filename):
        file_path = os.path.join(os.path.dirname(__file__), 'data', filename)
        try:
            with open(file_path, 'r') as file:
                lines = file.readlines()
                self.previous_lines = [line.strip() for line in lines]
                self.input_content = ""
                self.cursor_position = 0
                self.consolemsg(filename)
        except Exception as e:
            self.consolemsg(f"[Error loading file]")
        finally:
            self.hide_menu()

    def get_available_wifi_networks(self):
        try:
            # Run the nmcli command to list available WiFi networks
            result = subprocess.run(['nmcli', '-f', 'SSID', 'dev', 'wifi', 'list'], capture_output=True, text=True)
            output = result.stdout.strip()
            # Split the output into lines and extract the SSID of each network
            networks = [line.split()[0] for line in output.split('\n')[1:] if line.strip()]
            return networks
        except Exception as e:
            print(f"Error getting available WiFi networks: {e}")
            return []

    def new_file(self):
        self.save_file()
        self.previous_lines.clear()
        self.input_content = ""
        self.consolemsg("[New]")
        self.hide_menu()

    def power_down(self):
        #run powerdown script
        self.epd.Clear
        self.display_draw.rectangle((0, 0, 400, 300), fill=255)  # Clear display
        self.display_draw.text((55, 150), "ZeroWriter Powering Off", font=font24, fill=0)
        partial_buffer = self.epd.getbuffer(self.display_image)
        self.epd.display_Partial(partial_buffer)
        time.sleep(1)
        self.epd.init()
        self.epd.Clear()
        time.sleep(5)

        subprocess.run(['sudo', 'poweroff', '-f'])

    # autoupdate cool idea but shelving for now
    # def update_zerowriter(self):
    #     print("updating zerowriter")
    #     self.console_message = f"[Updating]"
    #     self.update_display()

    #     completed_process = subprocess.run(['git', 'pull'])
    #     if completed_process.returncode != 0:
    #         print(completed_process.stdout)
    #         print(completed_process.stderr)
    #         self.console_message = f"[Error updating]"
    #         self.update_display()
    #         time.sleep(1)
    #         self.console_message = ""
    #         self.update_display()
    #         return
    #     self.console_message = f"[Updated]"
    #     self.update_display()
    #     time.sleep(1)
    #     self.console_message = "Rebooting"
    #     self.update_display()
    #     self.reboot()

    # def reboot(self):
    #     print("rebooting")
    #     subprocess.run(['sudo', 'reboot', '-f'])

    def save_previous_lines(self, file_path, lines):
      try:
          # Ensure the directory exists
          os.makedirs(os.path.dirname(file_path), exist_ok=True)
          # Check if the file is writable or create it if it doesn't exist
          with open(file_path, 'a') as file:
              pass
          # Clear the file content before writing
          with open(file_path, 'w') as file:
              print("Saving to file:", file_path)
              for line in lines:
                  file.write(line + '\n')
      except IOError as e:
          self.consolemsg("[Error saving file]")
          print("Failed to save file:", e)

    def hide_menu(self):
        print("hide menu")
        self.menu_mode = False
        self.update_display()
        time.sleep(.25)
        self.update_input_area()

    def show_menu(self):
        print("show menu")
        self.menu_mode = True
        if self.parent_menu != None:
            self.menu = self.parent_menu
        self.selected_item = 0
        time.sleep(.25)
        self.menu.display()

    def display_qr_code(self):
        self.menu_mode = True        
        # Combine all previous lines into a single string
        qr_data = 'mailto:example@example.com?body=' + ' '.join(self.previous_lines)
        # Generate QR code
        # giving it no version will allow it to auto-detect the smallest version that will fit the data
        # currently does not handle extremely large files
        qr = qrcode.QRCode(
            error_correction=qrcode.constants.ERROR_CORRECT_L,
            box_size=2,
            border=4,
        )
        qr.add_data(qr_data)
        qr.make(fit=True)
        qr_img = qr.make_image(fill='black', back_color='white')
        # Convert QR code image to match the display's image mode
        qr_img_converted = qr_img.convert('1')
        # Save QR code to the filesystem
        qr_img_save_path = os.path.join(os.path.dirname(__file__), 'data', 'qr_code.png')
        qr_img.save(qr_img_save_path)
        print(f"QR code saved to {qr_img_save_path}")

        # Calculate position to center QR code on the display
        qr_x = (self.epd.width - qr_img_converted.width) // 2
        qr_y = (self.epd.height - qr_img_converted.height) // 2
        # Clear the display image
        self.display_draw.rectangle((0, 0, self.epd.width, self.epd.height), fill=255)
        # Paste the QR code onto the display image
        self.display_image.paste(qr_img_converted, (qr_x, qr_y))
        # Update the display with the new image
        partial_buffer = self.epd.getbuffer(self.display_image)
        self.epd.display_Partial(partial_buffer)

    def update_display(self):
        self.display_updating = True
        self.display_draw.rectangle((0, 0, 400, 300), fill=255)
        
        # Display the previous lines
        y_position = 270 - self.line_spacing  # leaves room for cursor input

        #Make a temp array from previous_lines. And then reverse it and display as usual.
        current_line=max(0,len(self.previous_lines)-self.lines_on_screen*self.scrollindex)
        temp=self.previous_lines[current_line:current_line+self.lines_on_screen]
        # print(temp)# to debug if you change the font parameters (size, chars per line, etc)

        for line in reversed(temp[-self.lines_on_screen:]):
          self.display_draw.text((10, y_position), line[:self.chars_per_line], font=font24, fill=0)
          y_position -= self.line_spacing

        #Display Console Message
        if self.console_message != "":
            self.display_draw.rectangle((300, 270, 400, 300), fill=255)
            self.display_draw.text((300, 270), self.console_message, font=font24, fill=0)
            self.console_message = ""
        
        #generate display buffer for display
        partial_buffer = self.epd.getbuffer(self.display_image)
        self.epd.display_Partial(partial_buffer)
        self.last_display_update = time.time()
        self.display_updating = False
        self.needs_display_update = False

    def update_input_area(self):
        if not self.menu_mode:
            cursor_index = self.cursor_position
            self.display_draw.rectangle((0, 270, 400, 300), fill=255)  # Clear display
            #add cursor
            temp_content = self.input_content[:cursor_index] + "|" + self.input_content[cursor_index:]
            #draw input line text
            self.display_draw.text((10, 270), str(temp_content), font=font24, fill=0)
            #generate display buffer for input line
            self.updating_input_area = True
            partial_buffer = self.epd.getbuffer(self.display_image)
            self.epd.display_Partial(partial_buffer)
            self.updating_input_area = False

    def insert_character(self, character):
        cursor_index = self.cursor_position
        
        if cursor_index <= len(self.input_content):
            # Insert character in the text_content string
            self.input_content = self.input_content[:cursor_index] + character + self.input_content[cursor_index:]
            self.cursor_position += 1  # Move the cursor forward
        
        self.needs_input_update = True

    def delete_character(self):
        if self.cursor_position > 0:
            # Remove the character at the cursor position
            self.input_content = self.input_content[:self.cursor_position - 1] + self.input_content[self.cursor_position:]
            self.cursor_position -= 1  # Move the cursor back
            self.needs_input_update = True

    def handle_key_down(self, e):
        if e.name == 'shift': #if shift is released
            self.shift_active = True
        if e.name == 'ctrl': #if shift is released
            self.control_active = True

    def save_file(self):
        timestamp = time.strftime("%m%d")  # Format: MMDD
        prefix = ''.join(self.previous_lines)[:20]
        alphanum_prefix = ''.join(ch for ch in prefix if ch.isalnum())
        filename = os.path.join(os.path.dirname(__file__), 'data', f'{timestamp}_{alphanum_prefix}.txt')
        self.save_previous_lines(filename, self.previous_lines)
        self.consolemsg("[Saved]")
        print("saved")

    def handle_key_press(self, e):
        
        if self.menu.inputMode:
            if len(e.name)==1:
                self.menu.input_content=self.menu.input_content+e.name
                print(self.menu.input_content)
                self.menu.inputDisplay()
            if e.name=="backspace":
                self.menu.input_content = self.menu.input_content[:-1]
                self.menu.inputDisplay()
            if e.name=="esc":
                self.menu.input_content=""
                time.sleep(.1)
                self.menu.display()
                time.sleep(.1)
                self.menu.inputMode=False
            if e.name=="enter":
                self.menu.input_content=""
                time.sleep(.1)
                self.menu.display()
                time.sleep(.1)
                self.menu.inputMode=False
            return


        if self.menu_mode:                

            if e.name == "w" or e.name == "up" or e.name == "left":
                self.menu.up()
            elif e.name == "s" or e.name == "down" or e.name == "right":
                self.menu.down()
            elif e.name == "enter":
                self.menu.select()
            elif e.name == "esc":
                self.hide_menu()
            return
        
        if e.name == "esc":
            self.show_menu()

        if e.name== "down" or e.name== "right":
          #move scrollindex down
          self.scrollindex = self.scrollindex - 1
          if self.scrollindex < 1:
                self.scrollindex = 1
          self.consolemsg(f'[{round(len(self.previous_lines)/self.lines_on_screen)-self.scrollindex+1}/{round(len(self.previous_lines)/self.lines_on_screen)}]')

        if e.name== "up" or e.name== "left":
          #move scrollindex up
          self.scrollindex = self.scrollindex + 1
          if self.scrollindex > round(len(self.previous_lines)/self.lines_on_screen+1):
                self.scrollindex = round(len(self.previous_lines)/self.lines_on_screen+1)
          self.consolemsg(f'[{round(len(self.previous_lines)/self.lines_on_screen)-self.scrollindex+1}/{round(len(self.previous_lines)/self.lines_on_screen)}]')
        
        if e.name== "s" and self.control_active: #ctrl+s save file
            self.save_file()
        if e.name== "n" and self.control_active: #ctrl+n new file
            self.new_file()
        if e.name == "q" and self.control_active: #ctrl+q qrcode
            self.display_qr_code()
        if e.name == "r" and self.control_active: #ctrl+r slow refresh
            self.epd.init()
            self.epd.Clear()
            self.update_display()
            
        if e.name == "tab": 
            #just using two spaces for tab, kind of cheating, whatever.
            self.insert_character(" ")
            self.insert_character(" ")
            # Check if adding the character exceeds the line length limit
            if self.cursor_position > self.chars_per_line:
                self.previous_lines.append(self.input_content)                
                # Update input_content to contain the remaining characters
                self.input_content = ""
                self.needs_display_update = True #trigger a display refresh
            # Update cursor_position to the length of the remaining input_content
            self.cursor_position = len(self.input_content)
            
            self.needs_input_update = True
            
        if e.name == "backspace":
            self.delete_character()
            self.needs_input_update = True
                
        elif e.name == "space": #space bar
            self.insert_character(" ")
            
            # Check if adding the character exceeds the line length limit
            if self.cursor_position > self.chars_per_line:
                self.previous_lines.append(self.input_content)                
                self.input_content = ""
                self.needs_display_update = True
            # Update cursor_position to the length of the remaining input_content
            self.cursor_position = len(self.input_content)
            self.needs_input_update = True
        
        elif e.name == "enter":
            if self.scrollindex>1:
                #if you were reviewing text, jump to scrollindex=1
                self.scrollindex = 1
                self.update_display()
            else:
                # Add the input to the previous_lines array
                self.previous_lines.append(self.input_content)
                self.input_content = "" #clears input content
                self.cursor_position=0
                #save the file when enter is pressed
                self.save_previous_lines(self.cache_file_path, self.previous_lines)
                self.needs_display_update = True
            
        if e.name == 'ctrl': #if control is released
            self.control_active = False 

        if e.name == 'shift': #if shift is released
            self.shift_active = False

        if len(e.name) == 1 and self.control_active == False:  # letter and number input
            if self.shift_active:
                char = keymaps.shift_mapping.get(e.name)
                self.input_content += char
            else:
                self.input_content += e.name

            self.cursor_position += 1
            self.needs_input_update = True

            # Check if adding the character exceeds the line length limit
            if self.cursor_position > self.chars_per_line:
                # Find the last space character before the line length limit
                last_space = self.input_content.rfind(' ', 0, self.chars_per_line)
                sentence = self.input_content[:last_space]
                # Append the sentence to the previous lines
                self.previous_lines.append(sentence)                

                # Update input_content to contain the remaining characters
                self.input_content = self.input_content[last_space + 1:]
                self.needs_display_update=True
                
            # Update cursor_position to the length of the remaining input_content
            self.cursor_position = len(self.input_content)                
            
        self.typing_last_time = time.time()
        self.needs_input_update = True

    def handle_interrupt(self, signal, frame):
      self.keyboard.unhook_all()
      self.epd.init()
      self.epd.Clear()
      exit(0)

    def loop(self):
        #if self.menu.inputMode:     
            #time.sleep(.2)          
            #self.menu.inputDisplay()

        if self.needs_display_update and not self.display_updating:
            self.update_display()
            self.update_input_area()
            self.typing_last_time = time.time()

        elif (time.time()-self.typing_last_time)<(.6):
            if not self.updating_input_area and self.scrollindex==1:
                self.update_input_area()

    def run(self):
        self.load_file_into_previous_lines("cache.txt")
        while True:
            self.loop()
